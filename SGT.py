# -*- coding: utf-8 -*-
"""SGT-module.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14yyMLrwDFbqrbvGzmS0fhyBq7T6EwFmI
"""

## Initialization
import argparse
parser = argparse.ArgumentParser(description = 'Analyses growth curves for the SGT-method.')

parser.add_argument('--checkerboard_nr', help = "Number of Checkerboards at the well-plate.")
parser.add_argument('--first_well', nargs='+', help = "First wells of all checkerboards on the plate.")
parser.add_argument('--last_well', nargs='+', help = "Last wells of all Checkerboards on the plate.")
parser.add_argument('--log_time', help = "Time in [min] that the investigated bacteria needs tto grow one log-level.")
parser.add_argument('--antibiotic_one_name', help = "Name of the first antibiotic.", default = 'Antibiotic 1')
parser.add_argument('--antibiotic_one_conc', nargs='+', help = "Concentrations of the first antibiotic.")
parser.add_argument('--antibiotic_two_name', help = "Name of the second antibiotic.", default = 'Antibiotic 2')
parser.add_argument('--antibiotic_two_conc', nargs='+', help = "Concentrations of the second antibiotic.")
parser.add_argument('--upload', help = "The file with your data.")
parser.add_argument('--cut_off', help = "Declare an CutOff-value for the SGT-calculation")
parser.add_argument('--automation_decision', help = "Do you want the programm to automatically compute µ_max or manually set boundaries for the linear area of the growth-curves?", choices = ['Yes', 'No'], default = 'No')

arg = parser.parse_args()
checkerboard_nr = int(arg.checkerboard_nr)
first_wells = arg.first_well[0].split(',')
last_wells = arg.last_well[0].split(',')
log_time = float(arg.log_time)
antibiotic_one_name = arg.antibiotic_one_name
antibiotic_one_conc = arg.antibiotic_one_conc[0].split(',')
antibiotic_two_name = arg.antibiotic_two_name
antibiotic_two_conc = arg.antibiotic_two_conc[0].split(',')
upload_file = arg.upload
cut_off = float(arg.cut_off)
decision_manual_automatic = str(arg.automation_decision)

if len(first_wells) > checkerboard_nr:
    print('To many first wells for checkerboards on plate.')
elif len(first_wells) < checkerboard_nr:
    print('To less first wells for checkerboards on plate.')

if len(last_wells) > checkerboard_nr:
    print('To many last wells for checkerboards on plate.')
elif len(last_wells) < checkerboard_nr:
    print('To less last wells for checkerboards on plate.')

checkerboards = []

for board in range(checkerboard_nr):
    checkerboards.append([board, first_wells[board], last_wells[board]])


################################################################################
## Module-import

import pandas as pd
import numpy as np
import altair as alt
import xlrd as rd
import string
import subprocess as sub
import os
import sys

def install(package):
    sub.check_call([sys.executable, "-m", "pip", "install", package])

install('altair_saver')
install('selenium')

sub.check_call(['apt-get', 'install', '-y', 'chromium-chromedriver'],
     stdout=open(os.devnull,'wb'), stderr=None) 


import altair_saver

from scipy.optimize import curve_fit


################################################################################
## File-conversion

data_xls = pd.read_excel(upload_file, sheet_name=0)
data_xls.to_csv('data.csv', encoding = 'utf-8')

################################################################################
## Parsing and conversion to dataframe

#check if first cell of uploaded file is empty:
if pd.notna(data_xls.iloc[0, 0]):
    
    #if TRUE parsing of Tecan-format starts:
    #creates lists of possible well-names:
    letter_list = list(string.ascii_uppercase)
    number_list = np.linspace(1, 50, 50)
    possible_wells = []

    for letter in letter_list:
        for number in number_list:
        
            possible_well = letter + str(int(number))
            possible_wells.append(possible_well)
    
    first_column_name = data_xls.columns[0]

    well_index_list = []
    
    #check for possible-wells in first column of file:
    for well in possible_wells:
    
       index = data_xls.loc[data_xls[first_column_name] == well, [first_column_name]].index.tolist()
    
       if len(index) > 0:
        
           well_index_list.append([well, index])

    time_list = []
    get_time_list = []
 
    #get time-values from file:
    get_time_list.extend(data_xls.iloc[(int(well_index_list[0][1][0]) + 1), 1:])

    time_list.append(['Well', get_time_list])

    well_values = []

    #for-loop over all wells found in the file:
    for well in range(len(well_index_list)):
    
        well_name = well_index_list[well][0]
        
        #checks if well-number is < 10:
        if int(well_name[1:]) < 10:
            
            #if TRUE a 0 is added between letter and number:
            well_name = well_name[0] + '0' + well_name[1:]
    
        well_values.append([well_name, list(data_xls.iloc[(int(well_index_list[well][1][0]) + 3), 1:].values)])

    time_list.extend(well_values)

    raw_data_dict = {}

    #for-loop over all times in the extended time_list:
    for times in range(len(time_list)):
    
        #sets the well-name (or in case of the time-data the string 'Well') as keys for their values in the dicitionary:
        raw_data_dict[str(time_list[times][0])] = time_list[times][1]

    #creates dataframe 'data_raw' with the dictionary:
    data_raw = pd.DataFrame(raw_data_dict)

    #transposes the dataframe:
    data_raw = data_raw.transpose()

    #sets the index to the first column:
    data_raw.reset_index(level=0, inplace=True)

    #sets the first row as column-names:
    data_raw.columns = data_raw.iloc[0]

    #deletes the first row
    data_raw = data_raw[1:]

    #displays dataframe 'data_raw':
    #print(data_raw)#[data_raw['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


elif pd.isna(data_xls.iloc[0, 0]):
    #Build a pandas dataframe from the .csv-file:
    data_raw = pd.read_csv('data.csv')

    #deletes rows with unnecessary information (temp.-values & measurement-data):
    data_raw = data_raw[:-5]
    data_raw = data_raw.iloc[1:]

    #brings the dataframe in an optimised form for plotting:
    data_raw = data_raw.rename(columns={'Unnamed: 0.1': 'Well'})
    del data_raw['Unnamed: 0']

    #deletes the 's' from the time-values:
    #for-loop over all columns
    for index in range(len(data_raw.columns)):
        data_raw.columns.values[index] =  data_raw.columns.values[index].replace('s', '')

    #add a '0' for Wells with single digit numbers:
    #for-loop over the row-count of the dataframe:
    for index in range(len(data_raw)):
        
        #check if well-name is two signs long:
        if len(data_raw.iloc[index, 0]) == 2:
            
            #if TRUE a 0 is added between the letter and number:
            string = data_raw.iloc[index, 0]
            string = string[:1] + '0' + string[1:]
            data_raw.iloc[index, 0] = string

    #displays dataframe 'data_raw':
    #print(data_raw)#[data_raw['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Wide-to-long-conversion

#uses the panda melt-command to bring the dataframe from wide to long form, where Well is an 'ID#, by which specific values (Time & Value) are identified:
data_melted = pd.melt(data_raw, id_vars = ['Well'], var_name = 'Time', value_name = 'Value')

#changes data type of the columns 'Time' & 'Value':
data_melted['Time'] = data_melted['Time'].astype(float)
data_melted['Value'] = data_melted['Value'].astype(float)

#displays new dataframe 'data_melted':
#data_melted#[data_melted['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Sigmoid curve-fitting

#Definition of the sigmoid-function:
def sigmoid(x, L, x0, k, n):                                                    #L = curve's maximum value; x0 = x-value of the sigmoid´s midpoint (turnpoint, where the curve is linear); k = logistic growth rate or steepness of the curve (; n = value for y at x = 0)
    y = L / (1 + np.exp(-k * (x - x0))) + n
    return y

#creates list of all wells in dataframe 'data_merged':
well_plate = list(data_melted['Well'])
well_plate = list(dict.fromkeys(well_plate))

fitted_values = []
popt_list = []

#for-loop over all wells of the plate:
for well in well_plate:
    
    #initialize data:
    x_data = list(data_melted[data_melted['Well'] == well]['Time']) 
    y_data = list(data_melted[data_melted['Well'] == well]['Value']) 
    
    #initialize start-parameters for curve_fit:
    y_max = max(y_data)
    y_min = min(y_data)
    k = (y_max/1000)          
    half_index = int(len(x_data)/2)
    x0 = data_melted[data_melted['Well'] == well].iloc[half_index, 1]                   
    
    #initialize parameters for the sigmoid-function (= L, x0, k, n)
    p0 = [y_max, x0, k, y_min]
    
    #curve_fit:
    popt, pcov = curve_fit(sigmoid, x_data, y_data, p0)
    
    popt_list.append([well, popt[0], popt[1], popt[2], popt[3]])

    #get fitted function from optimized parameters:
    fitted_y = sigmoid(x_data, *popt)
    
    fitted_values.append([well, np.array(x_data), fitted_y])
    
#displays list 'fitted_values':
#print(fitted_values)


################################################################################
## Computation of fitted data

fitted_data = []

#primary for-loop over all fitted values:
for wells in range(len(fitted_values)):
    
    #secondary for-loop over time-values for the actual well: 
    for position in range(len(fitted_values[wells][1])):
        
        #get well-name, time & fitted value
        well = fitted_values[wells][0]
        time = fitted_values[wells][1][position]                                        
        fitted_y = fitted_values[wells][2][position]
        
        fitted_data.append([well, time, fitted_y])

#creation of a second dataframe with the columns 'Well', 'Time' and 'Value' from the list 'fitted_data':
data_fitted = pd.DataFrame(fitted_data, columns = ['Well', 'Time', 'Fitted Value'])

#displays dataframe 'data_fitted':
#print(data_fitted)#[data_fitted['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Dataframe-merging

#create multiindex 'Well' and 'Time' for dataframe 'data_fitted':
data_fitted_multiindex = data_fitted.set_index(['Well', 'Time'], drop = True)

#check if dataframe 'data_merged' exist:
try:
    data_merged
except NameError:
    data_merged_exists = False
else:
    data_merged_exists = True

#if 'data_merged' exists:
if data_merged_exists == True: 
    
    #check if dataframe 'data_merged' already a has a column 'µ_max':
    if hasattr(data_merged, 'Fitted Value'):
    
        #if TRUE delete the column and merge 'data_µ_max' into 'data_merged':
        del data_merged['Fitted Value']
        data_merged = data_melted.join(data_fitted_multiindex, on = ['Well', 'Time'])

#if 'data_merged' doesn´t exist join 'data_µ_max' into 'data_merged':
else:
    data_merged = data_melted.join(data_fitted_multiindex, on = ['Well', 'Time'])

#display dataframe 'data_merged':
#print(data_merged)#[data_merged['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Plotting of the raw data and fitted sigmoid-curves

#get a list of all wells in dataframe 'data':
plate_wells = list(data_merged['Well'])

well_numbers = []

#for-loop over all wells in dataframe 'data_merged':
for wells in range(len(plate_wells)):
    
    #gets the number of the actual well and appends it to the array:
    well_numbers.append(plate_wells[wells][1:])

#deletes duplicates in the array:
well_numbers = list(dict.fromkeys(well_numbers))

#sets the number of rows in which graphs are plotted:
plot_columns = int(max(well_numbers))

#deactivates the max_row limit of altair for the processed dataframe:
alt.data_transformers.enable('default', max_rows=None)

#raw-data-plot:
raw_data = alt.Chart(data_merged).mark_point(opacity=0.4, color = "teal"

#columns to plot with specifications for the axis:
).encode(
    alt.X('Time:Q', scale=alt.Scale(domain=(0, 66000)), axis=alt.Axis(title='Time [s]')),
    alt.Y('Value:Q', axis=alt.Axis(title='OD (600 nm)'))

#properties of the resulting diagramm:
).properties(
    width = 300,
    height = 200
)

#fitted-data-plot:
fitted_curves = alt.Chart(data_merged).mark_line(color = "black"
).encode(
    alt.X('Time:Q'),
    alt.Y('Fitted Value:Q')
 )

#command to layer the raw- and fitted-data-plots over each other and split them into many diagramms depending on the well:
alt.layer(raw_data, fitted_curves, data = data_merged).facet(facet = 'Well', columns = plot_columns)


################################################################################
## Cut-off-determination

#cut_off = float(input("Set CutOff: "))


################################################################################
## µ-calculation & tangent-application

#variables matching the possible user-input for comparison in the if-condition:
decision_positive = 'Yes'
decision_negative = 'No'

#user-decision to progress either manually or automatic:
#print("This program offers you the possibility to determine the tangent for the linear area of the growth curves either manually or automatic.")
#decision_manual_automatic = input("Do you want to manually set an area for the tangent-calculation? Enter Yes/No: ")

#function to find value in a given array that is closest to a given value:
def find_nearest(array, value):                                                 
    
    #converts the given list/array/... to an array:
    array = np.asarray(array)
    
    #finds the index of the array-value, which results in the lowest absolute value by subtraction with the searched value:
    idx = (np.abs(array - value)).argmin()
    
    #returns the array-value:
    return array[idx]

#check if the user want to manually perform the tangent-fitting:
if decision_manual_automatic.lower() == decision_positive.lower():
    
    #User-input of the upper and lower boundaries for the linear curve area:
    upper_boundary = float(input("Enter the upper boundary for the linear growth area of the curves (e.g. 0.6): "))
    print('\n')
    lower_boundary = float(input("Enter the lower boundary for the linear growth area of the curves (e.g. 0.4): "))

    #Well-list:
    well_plate = list(data_merged['Well'])
    well_plate = list(dict.fromkeys(well_plate))

    boundary_values = []
    
    #for-loop over all wells:
    for well in well_plate:
        
        #variable that references the 'Fitted Value'-column of dataframe data_merged:
        fitted_value_column = data_merged[data_merged['Well'] == well]['Fitted Value']
        
        #searches the nearest fitted values to the user-specified boundaries for the actual well:
        nearest_upper_boundary = find_nearest(fitted_value_column, upper_boundary)
        nearest_lower_boundary = find_nearest(fitted_value_column, lower_boundary)
        
        #searches the corresponding times to the boundary-closest fitted values:
        upper_time = data_merged[(data_merged['Well'] == well) & (data_merged['Fitted Value'] == nearest_upper_boundary)]['Time'].values[0]
        lower_time = data_merged[(data_merged['Well'] == well) & (data_merged['Fitted Value'] == nearest_lower_boundary)]['Time'].values[0]
        
        #calculates the deltas for the boundary-values:
        delta_y = (upper_boundary - lower_boundary)
        delta_x = (upper_time - lower_time)
        
        #checks if division by 0 occured:
        if delta_x > 0 or delta_x < 0:
            
            #if False µ is calculated:
            µ = (delta_y / delta_x)
        
        else:
            µ = 'division by 0'
        
        boundary_values.append([well, upper_boundary, upper_time, lower_boundary, lower_time, µ])
    
    y0_list = []
    
    #for-loop over all wells in the second main-array:
    for well in range(len(boundary_values)):
        
        if type(boundary_values[well][5]) != str:
            
            #setup initial data:
            m = float(boundary_values[well][5])
            x = float(boundary_values[well][2])
            y = float(boundary_values[well][1])
    
            #compute n from y = mx + n:
            n = (y - (m * x))

            y0_list.append([boundary_values[well][0], m, n])
        
        else:
            
            m = boundary_values[well][5]
            n = 'not computable'
            y0_list.append([boundary_values[well][0], m, n])
    
    #create dataframe from the resulting array:
    data = pd.DataFrame(y0_list, columns = ['Well', 'µ_max', 'y0'])
    
    #display resulting dataframe:
    #print(data)

#
#
#check if the user want to autmatically perform the tangent-fitting:
if decision_manual_automatic.lower() == decision_negative.lower():
    
    #Well-list:
    well_plate = list(data_merged['Well'])
    well_plate = list(dict.fromkeys(well_plate))

    µ_values = []

    #primary for-loop over all wells:
    for well in well_plate:
    
        #row-count for that well as condition for secondary for-loop:
        row_count = data_merged[data_merged['Well'] == well].shape[0]
    
        µ = []
        time = []

        #secondary loop over all rows for that well:
        for row in range(1, row_count):
        
            #initialize data:
            actual_value = data_merged[data_merged['Well'] == well].iloc[(row - 1), 3]
            actual_time = data_merged[data_merged['Well'] == well].iloc[(row - 1), 1]
            next_value = data_merged[data_merged['Well'] == well].iloc[row, 3]
            next_time = data_merged[data_merged['Well'] == well].iloc[row, 1]
        
            #process data:
            delta_x = next_time - actual_time
            delta_y = next_value - actual_value
            m = (delta_y / delta_x)
            
            µ.append(m)
            time.append(next_time)
    
        µ_values.append([well, µ, time])

    #display resulting array:
    #print(µ_values)

    #define function to find max µ-values in array:
    def µ_max(array):
    
        µ_max_list = []
    
        #primary for-loop over all wells:
        for wells in range(len(array)):
        
            #setup initial data:
            well = array[wells][0]
            µ_max = array[wells][1][0]
            µ_max_time = array[wells][2][0]
        
            #secondary for-loop over all µ-values for that well:
            for value in range(1, len(array[wells][1])):
            
                #if-condition to compare µ-values and find max µ:
                if array[wells][1][value] >= array[wells][1][(value - 1)]:
                
                    #set new µ_max and corresponding time:
                    µ_max = array[wells][1][value]
                    µ_max_time = array[wells][2][value]
        
            µ_max_list.append([well, µ_max_time, µ_max])
        
        return µ_max_list

    #start function µ_max with the µ_values-array:
    µ_max_list = µ_max(µ_values)

    #set Pandas display-precision to show 3 decimal places:
    pd.set_option('display.precision', 3)

    #create a dataframe from the resulting array:
    data_µ_max = pd.DataFrame(µ_max_list, columns = ['Well', 'Time', 'µ_max'])

    #display resulting dataframe:
    #print("data_µ_max: ", data_µ_max, "\n")#[data_µ_max['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Dataframe-merging for automated µ-calculation

    #create multiindex 'Well' and 'Time' for dataframe 'data_µ_max':
    data_µ_max_multiindex = data_µ_max.set_index(['Well', 'Time'], drop = True)

    #check if dataframe 'data_merged' already a has a column 'µ_max':
    if hasattr(data_merged, 'µ_max'):
    
        #if TRUE delete the column and merge 'data_µ_max' into 'data_merged':
        del data_merged['µ_max']
        data_merged = data_merged.join(data_µ_max_multiindex, on = ['Well', 'Time'])

    #if FALSE merge 'data_µ_max' into 'data_merged':
    else:
        data_merged = data_merged.join(data_µ_max_multiindex, on = ['Well', 'Time'])

    #display dataframe 'data_merged':
    #print("data_merged:\n", data_merged, "\n")#[data_merged['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Creation of dataframe 'data'

    y0_list = []

    #for-loop over all wells:
    for wells in well_plate:
    
        #setup initial data:
        m = data_merged[(data_merged['Well'] == wells) & (pd.notna(data_merged['µ_max']))]['µ_max'].values[0]
        x = data_merged[(data_merged['Well'] == wells) & (pd.notna(data_merged['µ_max']))]['Time'].values[0]
        y = data_merged[(data_merged['Well'] == wells) & (pd.notna(data_merged['µ_max']))]['Fitted Value'].values[0]
    
        #compute n from y = mx + n
        n = y - m * x
    
        y0_list.append([wells, m, n])

    #create dataframe from the resulting array:
    data = pd.DataFrame(y0_list, columns = ['Well', 'µ_max', 'y0'])

    #display dataframe 'data':
    #print("data:\n", data)#[data['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'):")] #Optional: only a User-chosen Well is displayed


################################################################################
## SGT-calculation

#row-count as condititon for following loop:
row_count = data.shape[0]

#for-loop over all rows of 'data':
for row in range(row_count):
    
    #setup initial data:
    µ_max = data.loc[row, 'µ_max']
    y0 = data.loc[row, 'y0']
    
    #check if µ_max is no string:
    if type(data.loc[row, 'µ_max']) != str:
        
        #compute SGT and add it to 'data':
        data.loc[row, 'SGT'] = int(((cut_off - y0) / µ_max) / 60)
    
    else:

        data.loc[row, 'SGT'] = 'not computable'

#displays dataframe 'data':
#data#[data['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed

################################################################################
## log-level-reduction calculation

#get row-count of dataframe 'data':
row_count = data.shape[0]

calculated_values = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    #initialize data for if-conditions:
    first_well = str(checkerboards[boards][1])
    last_well = str(checkerboards[boards][2])
    
    #for-loop over all wells in dataframe 'data':
    for rows in range(row_count):
        
        #get name of the specific well:
        well_name = str(data.iat[rows, 0])

        #check if well is in the limits of the checkerboard:
        if well_name[0] >= first_well[0] and well_name[0] <= last_well[0]:
            if int(well_name[1:]) >= int(first_well[1:]) and int(well_name[1:]) <= int(last_well[1:]):
                
                if type(data.loc[rows,'SGT']) != str:
                    
                    #calculate data:
                    SGT_subtracted_value = int(data[data['Well'] == well_name]['SGT'].values[0] 
                                          - data[data['Well'] == first_well]['SGT'].values[0])
                    log_level_reduction = round((SGT_subtracted_value / log_time), 1)
                
                    #determine antibiotic-concentrations:
                    first_antibiotic_index = (ord(well_name[0]) - ord(first_well[0])) + 1
                    first_antibiotic_concentration = float(antibiotic_one[first_antibiotic_index])
                    second_antibiotic_index = int(int(well_name[1:]) - ((12 / board_count) * boards))
                    second_antibiotic_concentration = float(antibiotic_two[second_antibiotic_index])

                    #append data to main-array:
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])
                else:
                    print(well_name)
                    SGT_subtracted_value = 'not computable'
                    log_level_reduction = 'not computable'
                    first_antibiotic_index = (ord(well_name[0]) - ord(first_well[0])) + 1
                    first_antibiotic_concentration = float(antibiotic_one[first_antibiotic_index])
                    second_antibiotic_index = int(int(well_name[1:]) - ((12 / board_count) * boards))
                    second_antibiotic_concentration = float(antibiotic_two[second_antibiotic_index])
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])
        
        #check if well-letter is out of the checkerboard-bounds:
        elif well_name[0] <= first_well[0] or well_name[0] >= last_well[0]:
            if int(well_name[1:]) >= int(first_well[1:]) and int(well_name[1:]) <= int(last_well[1:]):
                
                if type(data.loc[rows,'SGT']) != str:
                    
                    #calculate data:
                    SGT_subtracted_value = int(float(data[data['Well'] == well_name]['SGT'].values[0]) 
                                      - float(data[data['Well'] == first_well]['SGT'].values[0]))
                    log_level_reduction = round((SGT_subtracted_value / log_time), 1)
                
                    #determine antibiotic-concentrations:
                    first_antibiotic_concentration = '-'
                    second_antibiotic_concentration = '-'

                    #append data to main-array:
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])
                
                else:
                    SGT_subtracted_value = 'not computable'
                    log_level_reduction = 'not computable'
                    first_antibiotic_concentration = '-'
                    second_antibiotic_concentration = '-'
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])
        
        #check if well-number is out of the checkerboard-bounds:
        elif int(well_name[1:]) <= int(first_well[1:]) or int(well_name[1:]) >= int(last_well[1:]):
            if well_name[0] >= first_well[0] and well_name[0] <= last_well[0]:
                
                if type(data.loc[rows,'SGT']) != str:
                    
                    #calculate data:
                    SGT_subtracted_value = int(data[data['Well'] == well_name]['SGT'].values[0] 
                                      - data[data['Well'] == first_well]['SGT'].values[0])
                    log_level_reduction = round((SGT_subtracted_value / log_time), 1)
                
                    #determine antibiotic-concentrations:
                    first_antibiotic_concentration = '-'
                    second_antibiotic_concentration = '-'

                    #append data to main-array:
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])

                else:
                    SGT_subtracted_value = 'not computable'
                    log_level_reduction = 'not computable'
                    first_antibiotic_concentration = '-'
                    second_antibiotic_concentration = '-'
                    calculated_values.append([well_name, SGT_subtracted_value, 
                        log_level_reduction, first_antibiotic_concentration, 
                        second_antibiotic_concentration])


#creates dataframe from calculated data:
data_calculated_values = pd.DataFrame(calculated_values, columns = ['Well',
    'SGT minus control', 'log-level-reduction',
    (antibiotic_one_name + '-concentration'),
    (antibiotic_two_name + '-concentration')])

#displays dataframe 'data_calculated_values':
#print(data_calculated_values)#[data_calculated_values['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Dataframe-merging

#set column 'Well' as index:
data_calculated_values_index = data_calculated_values.set_index(['Well'], drop = True)

antibiotic_one_column = str(antibiotic_one_name + '-concentration')
antibiotic_two_column = str(antibiotic_two_name + '-concentration')

#check if dataframe 'data' already has the columns from dataframe 'data_calculated_values'
#if TRUE delete the columns and merge 'data_calculated_values' into 'data':
if hasattr(data, 'SGT minus control'):
    del data['SGT minus control']
    
    if hasattr(data, 'log-level-reduction'):
        del data['log-level-reduction']
        
        if hasattr(data, antibiotic_one_column):
            del data[antibiotic_one_column]
            
            if hasattr(data, antibiotic_two_column):
                del data[antibiotic_two_column]
                data = data.merge(data_calculated_values_index, on = ['Well'])
            
            else:
                data = data.merge(data_calculated_values_index, on = ['Well'])
        else:
            data = data.merge(data_calculated_values_index, on = ['Well'])
    else:
        data = data.merge(data_calculated_values_index, on = ['Well'])

#if FALSE merge 'data_calculated_values' into 'data':
else:
    data = data.merge(data_calculated_values_index, on = ['Well'])

#display dataframe 'data':
#data#[data['Well'] == input("Choose well by entering the well-name (e.g.: 'A01'): ")] #Optional: only a User-chosen Well is displayed


################################################################################
## Determination of BBC-Wells

#get row-count of dataframe 'data':
row_count = data.shape[0]

first_antibiotic_bbcs = []
second_antibiotic_bbcs = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    first_antibiotic_concentrations =[]

    #initialize data for if-conditions:
    first_well = str(checkerboards[boards][1])
    last_well = str(checkerboards[boards][2])
        
    #for-loop over all wells in dataframe 'data':
    for rows in range(row_count):
        
        #get name of the specific well:
        well_name = str(data.iat[rows, 0])
        
        #check if well is within the limits of the checkerboard and accomplishs the log-level-reduction:
        if well_name[1:] == first_well[1:]:
            if well_name[0] >= first_well[0] and well_name[0] <= last_well[0]:
                if data[data['Well'] == well_name]['log-level-reduction'].values[0] >= 3.0:
                    
                    #get concentration of the first antibiotic in this well:
                    first_antibiotic_concentrations.append(data.loc[rows, antibiotic_one_column])

    first_antibiotic_bbcs.append(first_antibiotic_concentrations)

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    second_antibiotic_concentrations = []

    #initialize data for if-conditions:
    first_well = str(checkerboards[boards][1])
    last_well = str(checkerboards[boards][2])
        
    #for-loop over all wells in dataframe 'data':
    for rows in range(row_count):
        
        #get name of the specific well:
        well_name = str(data.iat[rows, 0])
        
        #check if well is within the limits of the checkerboard and accomplishs the log-level-reduction:
        if well_name[0] == first_well[0]:
            if well_name[1:] >= first_well[1:] and well_name[1:] <= last_well[1:]:
                if data[data['Well'] == well_name]['log-level-reduction'].values[0] >= 3.0:
                    
                    #get concentration of the second antibiotic in this well:
                    second_antibiotic_concentrations.append(data.loc[rows, antibiotic_two_column])

    second_antibiotic_bbcs.append(second_antibiotic_concentrations)

#print(first_antibiotic_bbcs, second_antibiotic_bbcs)

first_antibiotic_bbc = []
second_antibiotic_bbc = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    #append corresponding data from first main-arrays to new main-arrays:
    first_antibiotic_bbc.append(first_antibiotic_bbcs[boards][0])
    second_antibiotic_bbc.append(second_antibiotic_bbcs[boards][0])

#print(first_antibiotic_bbc, second_antibiotic_bbc)


################################################################################
## Determination of synergism

row_count = data.shape[0]

fici_values = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    #initialize data for if-conditions:
    first_well = str(checkerboards[boards][1])
    last_well = str(checkerboards[boards][2])
    
    #initialize data for computation:
    antibiotic_one_bbc = first_antibiotic_bbc[boards]
    antibiotic_two_bbc = second_antibiotic_bbc[boards]
    
    fici_value_per_well = []
    wells = []

    #for-loop over all wells in dataframe 'data':
    for rows in range(row_count):
        
        #get name of the specific well:
        well_name = str(data.iat[rows, 0])
        
        #check if well is in the limits of the checkerboarda and the log-level-reduction is >= 3:
        if well_name[0] > first_well[0] and well_name[0] <= last_well[0]:
            if int(well_name[1:]) > int(first_well[1:]) and int(well_name[1:]) <= int(last_well[1:]):
                if type(data.loc[rows, 'log-level-reduction']) != str:
                    if data[data['Well'] == well_name]['log-level-reduction'].values[0] >= 3.0:
                        actual_first_antibiotic_concentration = data[data['Well'] == well_name][antibiotic_one_column].values[0]
                        actual_second_antibiotic_concentration = data[data['Well'] == well_name][antibiotic_two_column].values[0]
                        well_fici_value = ((actual_first_antibiotic_concentration/antibiotic_one_bbc) + (actual_second_antibiotic_concentration/antibiotic_two_bbc))
                    
                        wells.append(str(well_name))
                        fici_value_per_well.append(well_fici_value)

    fici_values.append([wells, fici_value_per_well])

#print(fici_values)


################################################################################
## Identification of first wells in rows & columns

#defines a function which seeks the first letter in alphabetical order and the smallest number in an given list of well-names:
def well_naming(array):
    
    #sets the letter and number of the first well in the list:
    well_letter = array[0][0]
    well_number = array[0][1:]
    
    #tests for all wells of the list if the letter and number are smaller and if true sets them es new minimal value:
    for wells in range(len(array)):
        if array[wells][0] < well_letter:
            well_letter = array[wells][0]
        if array[wells][1:] < well_number:
            well_number = array[wells][1:]
    
    #returns the minimal letter and number of all wells:
    return well_letter, well_number

#get a list of all wells in dataframe 'data':
plate_wells = list(data['Well'])

well_letters = []
well_numbers = []
first_wells_in_rows_and_columns = []

#for-loop over all wells in dataframe 'data':
for wells in range(len(plate_wells)):
    
    #gets the letter and number of the actual well and appends them to the arrays:
    well_letters.append(plate_wells[wells][0])
    well_numbers.append(plate_wells[wells][1:])

#deletes duplicates in the arrays:
well_letters = list(dict.fromkeys(well_letters))
well_numbers = list(dict.fromkeys(well_numbers))

#for_loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    first_well_in_row = []
    first_well_in_column = []
    
    #gets the wells with an log-level-reduction >= 3:
    wells = fici_values[boards][0]
    
    #searches the minimal letter and number of this wells:
    well_min_letter_and_number = well_naming(wells)
    
    #for-loop over all letters that are part of an well-name in dataframe 'data':
    for letters in range(len(well_letters)):
        
        #takes the actual letter and searches the well-list for all wells with the letter in their name:
        letter = well_letters[letters]
        well_selection = [s for s in wells if letter in s]
        
        #checks if wells which names contain the letter were found:
        if len(well_selection) > 0:
            
            #gets the "smallest" of the selected ones (the first for this row) and appends it to the array:
            first_well = min(well_selection)
            first_well_in_row.append(first_well)
            
            #checks if the array contains a well with the minimal number in it´s name:
            end_well_number = well_min_letter_and_number[1]
            if first_well_in_row[-1][1:] == end_well_number:   
                
                #if TRUE the loop is interrupted
                break
    
    #for-loop over all numbers that are part of an well-name in dataframe 'data':
    for numbers in range(len(well_numbers)):
        
        #takes the actual number and searches the well-list for all wells with the number in their name:
        number = well_numbers[numbers]
        well_selection = [s for s in wells if number in s]
        
        #checks if wells which names contain the number were found:
        if len(well_selection) > 0:
            
            #gets the "smallest" of the selected ones (the first for this column) and appends it to the array:
            first_well = min(well_selection)
            first_well_in_column.append(first_well)
            
            #checks if the array contains a well with the minimal letter in it´s name:
            end_well_letter = well_min_letter_and_number[0]
            if first_well_in_column[-1][0] == end_well_letter:   
                
                #if TRUE the loop is interrupted
                break
    
    #extend the row-array with the column-array:
    first_well_in_row.extend(first_well_in_column)
    
    #deletes all duplicates in the extended row-array and saves it as new variable:
    first_wells_in_rows_and_columns.append(list(dict.fromkeys(first_well_in_row)))

#print(first_wells_in_rows_and_columns)


################################################################################
## FICI-value-calculation for determined first wells

board_fici_values = []
board_fici_values_with_well = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    corresponding_fici_value = []
    corresponding_fici_value_with_well = []
    
    #for-loop over all wells that are the first well of a row/column at that checkerboard:
    for wells in range(len(first_wells_in_rows_and_columns[boards])):
        
        #searches the index of the actual well in the fici-values-array:
        well_index = fici_values[boards][0].index(first_wells_in_rows_and_columns[boards][wells])
        
        #appends the fici_value which corresponds to this index to the arrays:
        corresponding_fici_value.append(fici_values[boards][1][well_index])
        corresponding_fici_value_with_well.append([first_wells_in_rows_and_columns[boards][wells], fici_values[boards][1][well_index]])
    
    board_fici_values.append(corresponding_fici_value)
    board_fici_values_with_well.append(corresponding_fici_value_with_well)

fici_average = []

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):
    
    #computes the average of the fici-values of the first wells in all rows and columns of the checkerboard:
    fici_average.append(np.average(board_fici_values[boards]))

#displays the resulting arrays:
# for boards in range(len(checkerboards)):
#     print("First wells of all rows and columns of Checkerboard %s with an log-level-reduction >= 3 and their corresponding FICI-value:"
#     %(boards + 1), '\n',
#     board_fici_values_with_well[boards],
#     '\n',
#     "The average of the FICI-values for this board is: ",
#     fici_average[boards],
#     '\n')


################################################################################
## Plotting of complete graphs

data_results_plot = data_merged.copy()

time_values = data_results_plot.loc[:, 'Time']
time_values = list(dict.fromkeys(time_values))

well_list = data_results_plot.loc[:, 'Well']
well_list = list(dict.fromkeys(well_list))

tangent_values = []

for wells in well_list:
    actual_well = wells
    µ = data[data['Well'] == actual_well]['µ_max'].values[0]
    n = data[data['Well'] == wells]['y0'].values[0]
    µ_max_index = data_results_plot[(data_results_plot['Well'] == wells) & (pd.notna(data_results_plot['µ_max']))]['µ_max'].index.values[0]
    data_results_plot.loc[µ_max_index, 'µ_max corresponding Value'] = data_results_plot.loc[µ_max_index, 'Fitted Value']
    if type(µ) != str:  
        for time in time_values:
            y = ((time * µ) + n)
            tangent_values.append([wells, time, y])

for elements in tangent_values:
    row_index = data_results_plot[(data_results_plot['Well'] == elements[0]) & (data_results_plot['Time'] == elements[1])].index[0]
    data_results_plot.loc[row_index, 'Tangent y-value'] = elements[2]

if decision_manual_automatic.lower() == decision_positive.lower():
    data_results_plot.loc[:, 'Upper Boundary'] = upper_boundary
    data_results_plot.loc[:, 'Lower Boundary'] = lower_boundary

plate_wells = list(data_results_plot['Well'])

well_numbers = []


for wells in range(len(plate_wells)):
    
    well_numbers.append(plate_wells[wells][1:])

well_numbers = list(dict.fromkeys(well_numbers))
plot_columns = int(max(well_numbers))

alt.data_transformers.enable('default', max_rows=None)

raw_data = alt.Chart(data_results_plot).mark_point(opacity=0.4, color = "teal"
).encode(
    alt.X('Time:Q', scale=alt.Scale(domain=(0, 66000)), axis=alt.Axis(title='Time [s]')),
    alt.Y('Value:Q', scale=alt.Scale(domain=(0, 1.5)), axis=alt.Axis(title='OD (600 nm)'))
).properties(
    width = 300,
    height = 200
)

fitted_curves = alt.Chart(data_results_plot).mark_line(color = "black"
).encode(
    alt.X('Time:Q'),
    alt.Y('Fitted Value:Q')
)

tangent = alt.Chart(data_results_plot
).mark_line(color = "orange", opacity = 0.5
).encode(
    alt.X('Time:Q'),
    alt.Y('Tangent y-value:Q')
).transform_filter(
    alt.FieldRangePredicate(field='Tangent y-value', range=[0, 1.5]))

if decision_manual_automatic.lower() == decision_positive.lower():
    
    upper_border = alt.Chart(data_results_plot).mark_line(color = "red", opacity = 0.35
    ).encode(
        alt.X('Time:Q'),
        alt.Y('Upper Boundary:Q')
    )

    lower_border = alt.Chart(data_results_plot).mark_line(color = "red", opacity = 0.35
    ).encode(
        alt.X('Time:Q'),
        alt.Y('Lower Boundary:Q')
    )

    plotted = alt.layer(raw_data, fitted_curves, tangent, upper_border, lower_border, data = data_results_plot).facet(facet = 'Well', columns = plot_columns)

else:
    µ_max_point = alt.Chart(data_results_plot).mark_point(color = "red"
    ).encode(
        alt.X('Time:Q'),
        alt.Y('µ_max corresponding Value:Q')
    )
    
    plotted = alt.layer(raw_data, fitted_curves, tangent, µ_max_point, data = data_results_plot).facet(facet = 'Well', columns = plot_columns)

plotted.save("chart.svg", scale_factor = 5.0)
plotted


################################################################################
## Summarise results

if os.path.exists('result.md') == True:
    os.remove("result.md")

if os.path.exists('formulas.md') == True:
    os.remove("formulas.md")

#creates copy of dataframe 'data':
data_results = data.copy()

#checks if the new dataframe contains the columns 'µ_max' & 'y0' and deletes them if TRUE:
if hasattr(data_results, 'µ_max'):
    del data_results['µ_max']
    
    if hasattr(data_results, 'y0'):
        del data_results['y0']

#reorders the columns of the dataframe:
data_results_columns = list(data_results.columns)
new_columns_order = [data_results_columns[0], data_results_columns[-2], data_results_columns[-1]]
new_columns_order.extend(data_results_columns[1:-2])
data_results = data_results[new_columns_order]

#creates empty dictionary:
checkerboard_dict = {}

#get row-count of dataframe 'data_results':
row_count = data_results.shape[0]

#for-loop over all checkerboards:
for boards in range(len(checkerboards)):

    #initialize data for if-conditions:
    first_well = str(checkerboards[boards][1])
    last_well = str(checkerboards[boards][2])

    #creates empty array:
    well_list = []
    
    #for-loop over all wells in dataframe 'data_results':
    for rows in range(row_count):
        
        #get name of the specific well:
        well_name = str(data_results.iat[rows, 0])
        
        #check if well is within the limits of the checkerboard and accomplishs the log-level-reduction:
        if well_name[0] >= first_well[0] and well_name[0] <= last_well[0]:
            if well_name[1:] >= first_well[1:] and well_name[1:] <= last_well[1:]:

                #if TRUE append well to list:
                well_list.append(well_name)
        
        elif well_name[0] <= first_well[0] or well_name[0] >= last_well[0]:
            if well_name[1:] >= first_well[1:] and well_name[1:] <= last_well[1:]:
                
                #if TRUE append well to list:
                well_list.append(well_name)
        
        elif well_name[1:] <= first_well[1:] or well_name[1:] >= last_well[1:]:
            if well_name[0] >= first_well[0] or well_name[0] <= last_well[0]:
                
                #if TRUE append well to list:
                well_list.append(well_name)
    
    #creates copy of dataframe 'data_results':
    data_results_copy = data_results.copy()

    #gets actual index + 1:
    boards_index = (boards + 1)
    
    #checks if the index is < 10:
    if boards_index < 10:
        
        #if TRUE a 0 is added in front of the index and the so numbered Checkerboard is used as key in the dicitionary which references the dataframe 'data_results_copy' without all rows whose well wasn´t in well_list. Sets the column with the well-names as index:
        checkerboard_dict["Checkerboard_0{0}".format(boards_index)] = data_results_copy.drop(data_results_copy[data_results_copy.Well.isin(well_list) == False].index).set_index('Well', drop = True).to_markdown()
    
    elif boards_index >= 10:
        
        #if FALSE the  Checkerboard is just numbered with the index and used as key in the dicitionary which references the dataframe 'data_results_copy' without all rows whose well wasn´t in well_list. Sets the column with the well-names as index:
        checkerboard_dict["Checkerboard_{0}".format(boards_index)] = data_results_copy.drop(data_results_copy[data_results_copy.Well.isin(well_list) == False].index).set_index('Well', drop = True).to_markdown()

#for-loop over all checkerboards in the dictionary:
for keys in range(len(checkerboard_dict)):
    actual_key = list(checkerboard_dict)[keys]
    #print(actual_key, '\n', checkerboard_dict[actual_key], '\n')
    
    #variable that references actual checkerboard from the dictionary
    result_md = checkerboard_dict[actual_key]
    
    #creates a file 'result.md' with the command to append data to it:
    result_file = open("result.md", "a")
    
    #writes data to the opened file:
    result_file.write('## ')
    result_file.write(actual_key)
    result_file.write('\nThe average FICI-value of the Checkerboard is:  ')
    result_file.write(str(fici_average[boards]))
    result_file.write('\n')
    result_file.write(result_md)
    result_file.write('\n\n')
    
    #closes the file:
    result_file.close()

data_sigmoid_parameters = pd.DataFrame(popt_list, columns = ['Well',
    'Sigmoid-function parameters: L', 'Sigmoid-function parameters: x0', 
    'Sigmoid-function parameters: k', 'Sigmoid-function parameters: n'])

data_formulas = data.copy()

del data_formulas['SGT minus control']
del data_formulas['log-level-reduction']
del data_formulas['Nitroxolin-concentration']
del data_formulas['Dalbavancin-concentration']

if hasattr(data_formulas, 'Sigmoid-function parameters: L'):
    del data_formulas['Sigmoid-function parameters: L']
    
    if hasattr(data, 'Sigmoid-function parameters: x0'):
        del data['Sigmoid-function parameters: x0']
        
        if hasattr(data_formulas, 'Sigmoid-function parameters: k'):
            del data_formulas['Sigmoid-function parameters: k']
            
            if hasattr(data_formulas, 'Sigmoid-function parameters: n'):
                del data_formulas['Sigmoid-function parameters: n']
                data_formulas = data_formulas.merge(data_sigmoid_parameters, on = ['Well'])
            
            else:
                data_formulas = data_formulas.merge(data_sigmoid_parameters, on = ['Well'])
        else:
            data_formulas = data_formulas.merge(data_sigmoid_parameters, on = ['Well'])
    else:
        data_formulas = data_formulas.merge(data_sigmoid_parameters, on = ['Well'])

else:
    data_formulas = data_formulas.merge(data_sigmoid_parameters, on = ['Well'])

data_formulas = data_formulas.set_index('Well', drop = True)
data_formulas = data_formulas.rename(columns={'µ_max': 'm', 'y0': 'n'})

formulas_md = data_formulas.to_markdown()

sigmoid_formula = 'y = L / (1 + e^(-k * (x - x0))) + n'
tangent_formula = 'y = m * x + n'

result_file = open("formulas.md", "a")
result_file.write('## Parameters of the tangent- and the sigmoid-function of each well\n\n')
result_file.write('Parameters for the formulars of the tangent- and sigmoid-function of each well.\n')
result_file.write('The tangent-function is defined as:\n')
result_file.write(tangent_formula)
result_file.write('\n\n')
result_file.write('The sigmoid-function is defined as:\n')
result_file.write(sigmoid_formula)
result_file.write('\n\n')
result_file.write(formulas_md)
result_file.close()


from google.colab import files
files.download('result.md')
files.download('formulas.md')
files.download('chart.svg')